<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack总结]]></title>
    <url>%2F2019%2F05%2F08%2Fwebpack%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[webpackwebpack把项目当做一个整体，通过一个给定的主文件，webpack从这个主文件开始找到项目所有依赖文件，使用loaders来处理打包成浏览器可识别的文件。install首先添加我们即将使用的包：1npm install webpack webpack-dev-server --save-dev webpack是我们需要的模块打包机webpack-dev-server用来创建本地服务器，监听你的代码修改，并自动刷新修改后的结果下面是有关dev-server的配置：1234567891011121314contentBase, // 为文件提供本地服务器port, // 监听端口，默认8080inline, // 设置为true,源文件发生改变自动刷新页面historyApiFallback // 依赖HTML5 history API,如果设置为true,所有的页面跳转指向index.htmldevServer:&#123; contentBase: &apos;./src&apos; // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新&#125;然后我们在根目录下创建一个&apos;webpack.config.js&apos;，在&apos;package.json&apos;添加两个命令用于本地开发和生产发布&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;, &quot;build&quot;: &quot;webpack&quot; &#125; entry: 用来写入口文件，它将是整个依赖关系的根12345var baseConfig = &#123; entry: &#123; main: &apos;./src/index.js&apos; &#125;&#125; output: 即使入口文件有多个，但是只有一个输出配置1234567891011var path = require(&apos;path&apos;) var baseConfig = &#123; entry: &#123; main: &apos;./src/index.js&apos; &#125;, output: &#123; filename: &apos;main.js&apos;, path: path.resolve(&apos;./build&apos;) &#125;&#125; module.exports = baseConfig loader作用：1 实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为jsloader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置，同时我们需要一个正则表达式来标识我们要修改的文件，然后有一个数组表示我们表示我们即将使用的Loader,当然我们需要的loader需要通过npm 进行安装，例如我们需要解析less的文件，那么webpack.config.js的配置如下：123456789101112131415161718192021222324252627var baseConfig = &#123; entry: &#123; main: &apos;./src/index.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(&apos;./build&apos;) &#125;, devServer: &#123; contentBase: &apos;./src&apos;, historyApiFallBack: true, inline: true &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: [ &#123;loader: &apos;style-loader&apos;&#125;, &#123;loader: &apos;css-loader&apos;&#125;, &#123;loader: &apos;less-loader&apos;&#125; ], exclude: /node_modules/ &#125; ] &#125;&#125; 下面是一些常用的loader:babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件;css-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loaderPlugins对整个构建过程起作用的外部引用例如： ExtractTextWebpackPlugin该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象1234567891011121314151617181920var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) var lessRules = &#123; use: [ &#123;loader: &apos;css-loader&apos;&#125;, &#123;loader: &apos;less-loader&apos;&#125; ] &#125; var baseConfig = &#123; // ... module: &#123; rules: [ // ... &#123;test: /\.less$/, use: ExtractTextPlugin.extract(lessRules)&#125; ] &#125;, plugins: [ new ExtractTextPlugin(&apos;main.css&apos;) ] &#125; HtmlWebpackPlugin依据一个简单的index.html模版，生成一个自动引用你打包后的js文件的新index.html1234567var HTMLWebpackPlugin = require(&apos;html-webpack-plugin&apos;) var baseConfig = &#123; // ... plugins: [ new HTMLWebpackPlug() ] &#125; HotModuleReplacementPlugin它允许你在修改组件代码时，自动刷新实时预览修改后的结果(注意永远不要在生产环境中使用HMR)webapck.config.js的全部内容:1234567891011121314151617181920212223242526272829303132const webpack = require(&quot;webpack&quot;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) var lessRules = &#123; use: [ &#123;loader: &apos;css-loader&apos;&#125;, &#123;loader: &apos;less-loader&apos;&#125; ] &#125; module.exports = &#123; entry: &#123; main: &apos;./src/index.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(&apos;./build&apos;) &#125;, devServer: &#123; contentBase: &apos;/src&apos;, historyApiFallback: true, inline: true, hot: true &#125;, module: &#123; rules: [ &#123;test: /\.less$/, use: ExtractTextPlugin.extract(lessRules)&#125; ] &#125;, plugins: [ new ExtractTextPlugin(&apos;main.css&apos;) ] &#125; 产品阶段的构建目前为止，在开发阶段的东西我们已经基本完成了。但是在产品阶段，还需要对资源进行别的处理，例如压缩，优化，缓存，分离css和js。首先我们来定义产品环境：123456789var ENV = process.env.NODE_ENV var baseConfig = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: JSON.stringify(ENV) &#125;) ] &#125; 然后还需要修改我们的script命令1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;NODE_ENV=developmenwebpack-dev-server&quot;, &quot;build&quot;: &quot;NODE_ENV=production webpack&quot;&#125; 当你引入那些不会进行生产的代码，下面这个代码将非常有用。123if (process.env.NODE_ENV === &apos;development&apos;) &#123; console.warn(&apos;这个警告会在生产阶段消失&apos;) &#125; 优化插件OccurenceOrderPlugin: 为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多 的模块，然后为他们分配最小的IDUglifyJsPlugin: 压缩代码下面是使用的方法：12345var baseConfig = &#123;// ...new webpack.optimize.OccurenceOrderPlugin()new webpack.optimize.UglifyJsPlugin()&#125; 然后在我们使用npm run build会发现代码是压缩的webpack打包原理把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段需加载webpack的优势1 以commonjs的形式书写脚本，对AMD和CMD的支持很全面方便旧代码进行迁移2 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等loader和plugin的区别loader用于加载某些资源文件。对于webpack本身无法加载的css，img等资源，需要对应的loader进行资源转化加载；plugin用于扩展webpack的功能，不局限于资源加载，还可以打包优化什么是bundle，什么是chunk，什么是modulebundle：是由webpack打包出来的文件chunk：是指webpack在进行模块依赖分析的时候，代码分割出来的代码块module：是开发中的单个模块webpack和gulp的区别webpack是一个模块打包器，强调的是前端模块化方案。我们可以把开发中的所有资源都看成是模块，通过loader和plugin对资源进行处理。gulp是一个前端自动化构建工具，自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。如何自动生成webpack配置文件webpack-cli/vue-cli模块热更新使得代码修改之后不用刷新浏览器就可以更新优点：只更新变更内容，以节省宝贵的开发时间]]></content>
      <categories>
        <category>概念解释</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础概念注释]]></title>
    <url>%2F2019%2F05%2F06%2FJS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[浏览器缓存浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。 CND缓存在浏览器和服务器间增加的一层缓存，缓存一些html、图片、css、xml等静态资源 如果中间加上一层CDN，那么用户浏览器与服务器的交互如下：客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个成http请求结束;如果数据已经过期，那么CDN还需要向源站发出回源请求(back to the source request),来拉取最新的数据。 DNS缓存 DNS就是(Domain Name System)“域名系统”的缩写，用来将主机名和域名转换为IP地址。 DNS缓存是指在正常访问ip之后，系统会将这个ip存储起来，当再次访问的时候，系统就会直接把本地的DNS缓存提取显示，等于是加速了网址的解析。 服务器缓存把服务器的内存划分出来一部分作为缓存，缓存客户机读取的数据 cookie和sessioncookie保存在浏览器端，是服务端发给客户端的特殊信息，以文本的方式保存在客户端，每次请求都会带上它。cookie机制：如果不设置过期时间，cookies的声明随浏览器的关闭而结束，称为会话cookies. 如果有过期时间，则直到过期时间才会消失。存储限制了数据量，只允许4KB session 称为会话信息，在web服务器上记录客户状态，记录的数据形式是对象，我们无法轻松访问会话值，因此它更安全。 localStorage和sessionStorage相同点： 均只能存储字符串类型的对象使用相同的API：1234567891011localStorage.setItem(&apos;key&apos;,&apos;value&apos;);//存储键值对localStorage.getItem(&apos;key&apos;)//获取名为&apos;key&apos;的值枚举localStorage的方法：for (var i=0;i&lt;localStorage.length;i++) &#123; var name = localStorage.key(i)​; var value = localStorage.getItem(name);​&#125;删除存储信息的键值对：localStorage.removeItem(&apos;key&apos;)//删除某一个localStorage.clear();// 清空localStorage中的所有信息 不同点： localStorage生命周期是永久，除非手动清除否则信息一直存在sessionStorage生命周期为当前窗口或标签页，一旦被关闭则存储数据永久清空渐进增强从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能优雅降级Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。线程与进程的区别进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。区分： 一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。清除浮动一般是一个盒子里使用了CSS float浮动属性，导致父级对象盒子不能被撑开，这样CSS float浮动就产生了。弊端：1 父元素背景不能显示 2 边框不撑开 3 margin padding设置值不能正确显示清除浮动方法：1 clear:both清除浮动新建样式和空标签：123.clear&#123; clear: both&#125;&lt;!-- 父元素最后面加入空div标签 --&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 2 父元素定义： overflow: hidden3 父元素div定义高度height4 父元素增加清除浮动代码：1234.clearfloat:after&#123;display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0&#125;.clearfloat&#123;zoom:1&#125;&lt;!-- 父元素 --&gt;&lt;div class=&quot;div1 clearfloat&quot;&gt;&lt;/div&gt; 媒体查询媒体查询，就是响应式布局。通过不同的媒介类型和条件定义样式表规则实例：12345678910111213141516171819/* 当浏览器的可视区域小于980px */@media screen and (max-width:980px) &#123; #wrap &#123;width： 90%; margin:0 auto;&#125; #content &#123;width： 60%;padding： 5%;&#125; #sidebar &#123;width： 30%;&#125; #footer &#123;padding： 8% 5%;margin-bottom： 10px;&#125;&#125;@media screen and (max-width: 650px) &#123;#header &#123;height： auto;&#125;#searchform &#123;position： absolute;top： 5px;right： 0;&#125;#content &#123;width： auto; float： none; margin： 20px 0;&#125;#sidebar &#123;width： 100%; float： none; margin： 0;&#125;&#125; 闭包闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。用处： 1 可以读取函数内部的变量2 让这些变量的值始终保持在内存中]]></content>
      <categories>
        <category>概念解释</category>
      </categories>
      <tags>
        <tag>JS高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报错总结]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[浏览器控制台报错1 xxxx is not definedxxx 没有定义考虑方向： xxx的文件是否已经引入到该页面xxx的引入路径有问题 或者关于xxx的js代码写的有问题 2 xxx is not a functionxxx不是一个函数考虑方向： xxx的事件的执行者未被绑定 3 cannot read property “xxx” of undefined不能读取undefined的xxx属性考虑方向：拥有xxx属性的对象为undefined 尝试检查输出一下这个对象“Cannot set property ‘xxx’ of null”同理 4 Invalid or unexpected token捕获的查询无效或意外的标记考虑方向: 代码逻辑没有问题，数据上有问题，可能有多余或残缺的单引号双引号等错误特殊符号 5 Unexpected token a in JSON at position 0json解析异常考虑方向: 关注json的返回数据，注意检查其返回内容和内容的格式是否正确，json文件内部是否符合格式规范 7、XMLHttpRequest cannot load http://XXXXXX. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://XXXXXX&#39; is therefore not allowed access.使用ajax请求数据时，产生跨域了考虑方向： 解决跨域问题 8 Illegal break statement出现了非法语句考虑方向：代码格式错误，break所在位置错误 9、SyntaxError(语法错误)语法错误考虑方向：可能出现中文字符 10、ReferenceErro（引用错误）引用一个不存在的变量时发生的错误考虑方向：在作用域中找不到该变量 11、TypeError（类型错误）变量或参数不是预期类型时发生的错误考虑方向： 调用对象不存在的方法，比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误 12 GET file:///D:/JavaBooks/js/jquery%20validation/src-gzh/jquery.validate-1.7.src net::ERR_FILE_NOT_FOUND找不到引入的文件，考虑方向：文件名错误或路径错误 13 Uncaught TypeError: Cannot set property ‘onclick’ of null找不到onclick绑定的按钮节点考虑方向：js文件放在底部加载，文档解析先加载DOM在加载js文件，使用window.onload=function(){}包裹也可以 cmd 中的报错不是内部或外部命令，也不是可运行的程序或批处理文件由于环境变量配置不当，导致windows系统无法正确找到目标考虑方向： 配置环境变量或者没有安装此指令的程序 其他报错待收集……….大致解决方向： 依赖包没有安装，依赖包版本不符，运行的内部代码出现语法错误，配置方面的缺漏]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基础字符释义\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符例如想要查找.和*或者\等就要使用\. 和 \* 和\\\b 代表着单词的开头或结尾，也就是单词的分界处 例如\bhi\b^ 匹配输入字符串的开始位置$ 匹配输入字符串的结束位置* 匹配前面的子表达式可以连续使用零次或多次+ 匹配前面的子表达式一次或多次? 匹配前面的子表达式零次或一次{n} n是一个非负整数。匹配前面的字符确定的n次{n,} n是一个非负整数。至少匹配n次{n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。. 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。x|y 匹配x或y[xyz] 字符集合。匹配所包含的任意一个字符[^xyz] 负值字符集合。匹配未包含的任意字符\d 匹配一个数字字符 等价于[0-9]\D 匹配一个非数字字符 等价于[^0-9]\w 匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_]\W 匹配任何非单词字符。等价于[^A-Za-z0-9_]\n是换行 \r是回车 \r\n表示回车换行 \t表示键盘上的“TAB”键 1 检验数字的表达式1 数字： ^[0-9]*$2 n位数字：^\d{n}$3 至少n位数字：^\d{n,}$4 m-n位的数字：^\d{m,n}$5 零和非零开头的数字：^(0|[1-9][0-9]*)$6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$ 2 校验字符的表达式1 汉字：^[\u4e00-\u9fa5]{0,}$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$3 长度为3-20的所有字符：^.{3,20}$4 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 特殊需求1 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?3 InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$5 身份证号(15位、18位数字)：^\d{15}|\d{18}$6 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$7 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$8 HTML 标签 ^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$ ip地址： (\d{1,3}.){3}\d{1,3} (?0\d{2}[)-]?\d{8}0\d{2}-\d{8}|0\d{3}-\d{7}]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax的原理与使用]]></title>
    <url>%2F2019%2F04%2F28%2FAjax%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是AjaxAjax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等 原理 Ajax的使用1.创建Ajax核心对象XMLHttpRequest(记得考虑兼容性)1234567var xhr = null;if (window.XMLHttpRequest) &#123;// 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr = new XMLHttpRequest();&#125;else&#123;// 兼容 IE6, IE5 xhr = new ActiveObject(&quot;Microsoft.XMLHTTP)&#125; 2 向服务器发送请求12xhr.open(method,url,async);send(string)//post请求时才使用字符串参数，否则不用带参数。 method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步）例如： 发送post请求时(注：post请求一定要设置请求头的格式内容)123xhr.open(&quot;POST&quot;,&quot;test.html&quot;,true);xhr.setRequestHeader(&quot;Content-type&quot;,&quot;applicationx-www-form-urlencoded&quot;)xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;); 3 服务器响应处理responseText 获得字符串形式的响应数据。responseXML 获得XML 形式的响应数据异步处理：12345xhr.onreadystatechange = function() &#123; if (xhr.ReadyState==4 &amp;&amp;xhr.status==200)&#123; document.getElementById(&quot;myId&quot;).innerHTML = xhr.responseText &#125;&#125; readyState0-（未初始化）还没有调用send()方法1-（载入）已调用send()方法，正在发送请求2-（载入完成）send()方法执行完成，已经接收到全部响应内容3-（交互）正在解析响应内容4-（完成）响应内容解析完成，可以在客户端调用了③GET和POST请求数据区别GET请求的参数数直接拼接在url上面POST请求的参数就不是放在url了，而是放在send里面，即请求体 jQuery使用Ajax12345678910111213//页面加载 获取全部信息$(function () &#123; $ajax(&#123; type: &apos;POST&apos;,//请求方式 url:&apos;item.json&apos;//地址，就是json文件的请求路径 dataType: &apos;json&apos;,//数据类型可以为 text xml json script jsonp success: function(data)&#123; console.log(data)//在控制台打印服务器端返回的数据 &#125; error:function (data) &#123; alert(data.result); &#125;)&#125;) 使用axios发出异步请求123456789created() &#123; axios.get(&apos;/user?ID=12345&apos;) .then(function(response)&#123; console.log(response) &#125;) .catch(function(error)&#123; console.log(error) &#125;)&#125;]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目搭建初步认知]]></title>
    <url>%2F2019%2F04%2F26%2Fvue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[使用vue-cli快速创建的vue项目目录如下： build : webpack相关配置以及服务启动文件，配置多依赖于下边的config文件夹中内容 config : vue基本配置文件，如监听端口，打包输出等配置 node_modules : 安装依赖包的目录文件 src – 页面以及业务逻辑文件夹，在此文件夹下进行项目开发 static – 静态资源，可存放一些不需要进行打包的资源文件 .babelrc – ES6语法编译配置，用来将ES6代码转换为浏览器识别的代码(ES6转ES5) .editorconfig – 代码规范化配置文件 .gitignore – git上传需要忽略的文件格式 .postcssrc.js – 转换css工具，用js来处理css index.html – 页面入口 package.json – 项目基本信息，项目开发所需的模块，项目名称，版本等 readme.txt – 项目说明，说明一下此项目作何使用等。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化项目]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[github上创建仓库 得到仓库地址 本地根目录初始化项目文件夹打开gitbash 执行以下命令:1vue init webpack proName 注： 最后两个选项选择no，其他yes和回车 上传github仓库123456git initgit add .git commit -m &apos;first commit&apos;&lt;!-- 网址复制下面 --&gt;git remote add origin http://github.com/......git push -u origin master 初始设置视口设置1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 初始化css 样式创建assets文件夹，放入reset.css 和border.cssmain.js文件中引用： import ‘styles/reset.css’及import ‘styles/border.css’ 初始化需要安装的工具包stylus 与stylus-loader12npm install stylus --savenpm install stylus-loader --save 300ms延迟问题fastclick12345&lt;!-- 安装 --&gt;npm install fastclick --save&lt;!-- main.js中引用 --&gt;import fastClick from &apos;fastClick&apos;fastClick.attach(document.body) webpack.base.config里面的设置12345678910&lt;!-- 简化路径 --&gt;resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &apos;styles&apos;: resolve(&apos;src/assets/styles&apos;), &apos;common&apos;: resolve(&apos;src/common&apos;) &#125;&#125;, config文件夹里面的index.js123456789101112131415&lt;!-- 修改api路径 模拟数据传入 --&gt;module.exports = &#123; dev: &#123; // Paths assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8080&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock/&apos; &#125; &#125; &#125;, src是主要操作及使用文件夹可添加common文件夹放置公用组件可添加assets文件夹放置公用的style字体css样式，styl样式可添加pages存放不同页面组件文件夹可添加store存放vuex所需的index.js文件static里创建mock文件夹存放json数据 gitignore存放上传时需要隐藏的文件1234567.DS_Storenode_modules//dist/npm-debug.log*yarn-debug.log*yarn-error.log*static/mock axios模块 使用ajax123456789101112131415161718192021222324npm install axios --save&lt;!-- 在需要数据传输的主组件引用 --&gt;import axios from &apos;axios&apos;&lt;!-- get数据 --&gt;methods: &#123; getHomeInfo () &#123; axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc) &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data ) &#123; const data = res.data &lt;!-- 本组件中的data里面要已经创建好list数据 --&gt; this.list = data.swiperList &#125; &#125;&#125;mounted () &#123; this.getHomeInfo()&#125;&lt;!-- get到的数据传入到子组件中 --&gt;&lt;home-swiper :list=&quot;list&quot;&gt;&lt;/home-swiper&gt;子组件使用props接收使用 每次路由切换的时候都进入的页面初始位置x,y轴都为0123scrollBehavior (to, from, savedPosition) &#123; return &#123;x: 0, y: 0&#125; &#125; better-scroll移动端滚动的解决方案12345678910111213141516171819npm install better-scroll --save &lt;!-- 需要使用的组件中使用 保证该组件的html结构如下 --&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;content&quot;&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- you can put some other DOMs here, it won&apos;t affect the scrolling --&gt;&lt;/div&gt;&lt;!-- 引用 --&gt;import Bscroll from &apos;better-scroll&apos;&lt;!-- 创建mounted生命周期钩子 --&gt;mounted () &#123; this.scroll = new Bscroll(this.$refs.wrapper)&#125;&lt;!-- 需要设置的盒子设置 ref --&gt;&lt;div class=&quot;list&quot; ref=&quot;wrapper&quot;&gt; &lt;/div&gt; 设置数据接口先将json数据放在static文件夹的mock中在build文件夹的webpack.dev.config文件中作如下设置12345678910111213141516171819202122232425262728...........const portfinder = require(&apos;portfinder&apos;)const express = require(&apos;express&apos;)const app = express()var appData = require(&apos;../static/mock/data.json&apos;)var seller = appData.sellervar goods = appData.goodsvar ratings = appData.ratingsvar apiRoutes = express.Router()app.use(&apos;/api&apos;,apiRoutes)devServer:&#123; ............ before(app)&#123; app.get(&apos;/api/seller&apos;,function(req,res)&#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;), app.get(&apos;/api/goods&apos;,function(req,res)&#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;), &#125; 现在在浏览器输入http://localhost:8080/api/seller即可得到seller数据 点击路由高亮 &amp;.router-link-active1234567.tab-item flex: 1 text-align: center font-size: 14px color: rgb(77,85,93) &amp;.router-link-active color: rgb(240,240,20) 修改边框颜色123.border-bottom &amp;:before border-color: red 在vue中使用es6语法${}引用12345678910payDesc () &#123; if (this.totalPrice == 0 ) &#123; return `￥$&#123;this.seller.minPrice&#125;元起送` &#125;else if (this.totalPrice &lt; this.minPrice) &#123; let diff = this.minPrice - this.totalPrice return `还差￥$&#123;diff&#125;元起送` &#125;else &#123; return &apos;去结算&apos; &#125;&#125;, 使盒子水平排列的方法1 position (父)relative （子）absolute2 （子）float left right3 (父) display: flex 子flex: 1 或flex: 0 0 20px4 （子） display: inline-block 使用了better-scroll的区域点击失效使用click:true1234this.foodsscroll = new Bscroll(this.$refs.fwrapper,&#123; click: true, probeType: 3 &#125;) 外卖项目注：v-show能接收到food的count值1Vue.set(this.food,&apos;count&apos;,1)]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>搭建</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端试题]]></title>
    <url>%2F2019%2F04%2F07%2Fexamination%2F</url>
    <content type="text"><![CDATA[第一章：全局作用域与私有作用域，变量提升 112345678console.log(a); //a 是全局变量 var a = 12; // 预解析变量提升 提升后不赋值，使a为undefinedfunction fn()&#123; // 私有作用域内声明了一个私有变量a 道理同上为undefined console.log(a); var a = 13; &#125;fn(); // (补充：fn执行形成一个私有作用域，1相残赋值,没有形参 2 变量a提升，所以fn内的所有a都是私有变量)console.log(a) // 此处的a为全局变量，12 答案： undefined undefined 12 212345678console.log(a);//此处同1号题var a = 12;function fn()&#123; console.log(a); a = 13; //此处和1号题区别，没有var声明，则此局部作用域内的a为全局变量，所以a被赋值了13&#125;fn();console.log(a); 答案： undefined 12 13 312345678console.log(a);// 全局作用下提升变量 报错 控制台只有报错信息a = 12; // 没有var 则不需要提升function fn()&#123; console.log(a); a = 13;&#125;fn(); console.log(a);// 补充：如果去掉第一行代码，以下正常执行输出12 13 答案： 有程序报错 412345678var foo = 1; //声明全局变量foo为10function bar()&#123; //形参赋值：无；变量提升：foo(不管下面的条件成立是否都要提升只是新浏览器中对于判断体的函数只是提前声明) if(!foo)&#123; //此时私有foo是undefined 取反为true 执行代码 var foo = 10; &#125; console.log(foo);&#125;bar(); 答案： 10 512345678910111213var n = 0 ;function a()&#123; var n = 10; function b()&#123; n++; console.log(n); &#125; b(); return b;&#125;var c = a();c();console.log(n); 答案：11 12 0 612345678910var a = 10,b = 11, c = 12;function test(a)&#123; a = 1; //a 是该函数的形参为私有变量，但是实参为10，此时a为10 var b = 2; //b被声明，所以为私有变量 赋值2 c = 3; // c在全局被声明，此处的c为全局变量，且重新赋值为3&#125;test(10);console.log(a);console.log(b);console.log(c); 答案：10 11 3 71234if(!(&quot;a&quot; in window))&#123;//注意：此大括号内为块级作用域，a为全局作用域的变量，即使条件不成立也会提前声明为undefined var a = 1;&#125;console.log(a); 答案：undefined(补充：相当于给window设置了一个对象的属性，而且两者间建立了映射的机制，所以此处&lt;=&gt;window.a = undefined; in:检测某个属性是否隶属于这个对象，不管是私有还是公有，有的话就是true。hasOwnProperty检测是否为某个对象的私有属性。) 812345678var a = 4;function b(x,y,a)&#123; console.log(a); // 与以上题目道理相同 arguments[2] = 10; // 第三个实参值修改为10 console.log(a);&#125;a = b(1,2,3);// b执行没有return,默认返回undefined，则a成为了undefinedconsole.log(a); 答案：3 10 undefined（补充：arguments[]—函数内置的实参集合，不管是否设置形参值，传递的实参值都会存在里面,JS非严格模式下,函数中的形参变量和arguments存在映射机制,形参变量的值会随着arguments []的值修改。严格模式：“use strict” 下的分析，如下：123456789function fn(x,y)&#123; var arg = arguments; arg[0] = 100; //arg内部只有一个映射 console.log(x); // 100 y = 200; consle.log(y);// y 赋值为200 console.log(arg[1]);//arg内部没有arg[1],所以为undefined&#125;fn(10);// 此时只为x赋值,y为undefined ） Tips: 严格模式与非严格模式下的区别1 严格模式下不支持使用arguments.callee和arguments.caller。2 严格模式下arguments和形参没有映射机制3 严格模式下，不允给一个对象的属性重复设置值，会出现两次值，而非严格模式是修改效果4 严格模式下，函数执行，如果没有明确指定主体（即函数前面没有点），就不再像非严格模式下一样把this指向window,而是指向undefined，代表没有执行主体。只有存在的情况下才指向执行主体 第二章：逻辑或||和逻辑与&amp;&amp;11234567var foo = &quot;hello&quot;;(function(foo)&#123; //形参赋值foo，变量提升省略，因为已经有foo这变量了，浏览器不会重新声明 console.log(foo); var foo = foo||&quot;world&quot;; // console.log(foo);&#125;)(foo);//将全局下的foo的值作为实参传递给自执行函数的形参console.log(foo); 答案：hello hello hello补充：使用到逻辑与和逻辑或的场合：(逻辑与的运算优先级高于逻辑或参照逻辑运算符)1 条件判断中使用到（两者都成立或有一个成立则判断条件才成立）2 赋值操作。var a = “1||2” ,验证1的真假：若1为真，赋值1；若为假，赋值2；var a=1&amp;&amp;2,验证1的真假：若为真，赋值2；若为假，赋值1。 第三章：堆栈内存释放112345678910111213！待定：var a = 9;function fn()&#123; a = 0;//私有变量a return function(b)&#123; return b+a++;//此处++不参与运算，但a也会加1加上括号（++）也一样 &#125;&#125;var f=fn();console.log(f(5)); //此处和下面同一个意思，都是5，但是其中的a未被销毁console.log(fn()(5));// a的值未被占用，被销毁console.log(f(5)); //f指针指向的第二次执行 a已经为1 console.log(a); 答案：5 5 6 2 21234567891011var i = 10;function fn()&#123; return function (n)&#123; console.log(n+(++i)); //此处i为全局变量，且++计算入总结果注意与上题区别 &#125; &#125;var f = fn();f(20);fn()(20)fn()(30)f(30) 答案: 31 32 43 44 312345678910var ary = [1,2,3,4];//开辟一个堆内存，让全局下的ary=bbbfff111function fn(ary)&#123; //把全局的ary的值传给了私有ary ary[0] = 0;//给里面的ary重新赋值[0,2,3,4] 因为两个ary指针指向同一个地方 ary = [0]; //开辟一个新的空间 ary=bbbfff222对应[0（0）] ary[0] = 100;// 现在改成[0（100）] return ary;// 相当于return bbbfff222&#125;var res = fn(ary);// res = fn(bbbfff111)=bbbfff222,这里有指针指向的改变console.log(ary);//[0,2,3,4]console.log(res); //[100] 答案： [0,2,3,4] [100]基本类型和引用类型]]></content>
      <categories>
        <category>知识点剖析</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建基本步骤]]></title>
    <url>%2F2019%2F04%2F07%2Fblog-construction%2F</url>
    <content type="text"><![CDATA[关于博客的基本概念来源：博客一词来源于weblog（网络日记），而喜欢新名词的人故意将该词变换称为“we blog”，就此诞生了“blog”极其音译“博客”，而编写该日志的人则被称为”blogger“，即博主。 作用：简单来说，blog就是以网络为载体的综合性平台，由简单易懂且经常更新的帖子构成，这些帖子按照更新时间倒序排列，其中可以记录你在生活，工作等任何领域的想法观点，上传自己想收藏起来的照片视频音频等文件，还可以与他人进行轻松有效的交流。 现在开始搭建博客：1 ：全局配置等准备工作1 安装Node.js和配置Node.js环境，官网直接下载即可。这是一个安装细节传送门检验是否安装成功：打开cmd命令行，由于是全局安装所以不需要修改文件夹。键入如下字符显示版本,则代表已经安装好，同时键入npm -v也会出现版本号，这是由于node.js附带安装了npm包管理工具1234C:\Users\Administrator&gt;node -vv10.15.3C:\Users\Administrator&gt;npm -v6.9.0 2 去github官网注册一个账号3 安装git工具：Git官网直接下载安装程序，安装完成后在cmd中输入git弹出命令行窗口，则表示安装成功，下面就要绑定自己的github账号12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 2 ： 开始安装HEXO1 创建blog文件夹，进入文件夹中右键git打开命令行输入命令1npm install -g hexo-cli 可以使用hexo -v查看版本，安装完成2 初始化hexo 为自己的blog取名。cd到文件夹中安装依赖123hexo init myblogcd myblognpm install 3 命令行中输入hexo g 生成静态页面，hexo s开启服务，根据提示端口号进入页面123hexo ghexo sINFO Hexo is running at http://localhost:4000/ 到目前为止，HEXO在本地的配置已经结束，我们下面要将本地的代码上传到github上 3 ： github配置1 前面我们已经注册好了一个github账号，点击NEW repository新建代码仓库创建页面在在Repository name 下面填写yourname.github.ioyourname就是你想要使用的名字，下面的描述可以不写，点击创建即可2 现在让本地的git项目与远程的github建立联系，使用SSH keys3 生成SSH Keys : 在命令行中使用如下命令，输入你自己的邮箱地址1ssh-keygen -t rsa -C &quot;xxxx@qq.com&quot; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码4 添加 SSH Key 到 GitHub: 打开 C:\Users\lijun.ssh\id_rsa.pub，此文件里面内容为刚生成的密钥，准确的复制这个文件里的内容，粘贴到 https://github.com/settings/ssh 的new SSH key中5 测试是否添加成功 :可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：1ssh -T git@github.com 出现如下反馈123The authenticity of host ‘github.com (207.97.227.239)’ can’t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 下面键入yes出现成功提示1Hi AnkZhang! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 6 配置 Deployment在_config.yml文件中(此文件在你创建好的Hexo站点目录中)，找到Deployment，然后按照如下修改，用户名改成你自己的GitHub信息：(冒号后一定要空一格)123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/AnkZhang/AnkZhang.github.io.git branch: master 7 本地文件提交到github123456// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate// 开始部署hexo deploye 出现以下提示说明部署成功：1[info] Deploy done: git 注意1：若上面操作失败，则需要提前安装一个扩展：1npm install hexo-deployer-git --save 注意2：如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。1234Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 4： HEXO常用命令1234567891011121314hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 就此HEXO博客搭建完成]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>搭建</tag>
        <tag>安装</tag>
      </tags>
  </entry>
</search>
