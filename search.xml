<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初始化项目]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[github上创建仓库 得到仓库地址 本地根目录初始化项目文件夹打开gitbash 执行以下命令:1vue init webpack proName 注： 最后两个选项选择no，其他yes和回车 上传github仓库123456git initgit add .git commit -m &apos;first commit&apos;&lt;!-- 网址复制下面 --&gt;git remote add origin http://github.com/......git push -u origin master 初始设置视口设置1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 初始化css 样式创建assets文件夹，放入reset.css 和border.cssmain.js文件中引用： import ‘styles/reset.css’及import ‘styles/border.css’ 初始化需要安装的工具包stylus 与stylus-loader12npm install stylus --savenpm install stylus-loader --save 300ms延迟问题fastclick12345&lt;!-- 安装 --&gt;npm install fastclick --save&lt;!-- main.js中引用 --&gt;import fastClick from &apos;fastClick&apos;fastClick.attach(document.body) webpack.base.config里面的设置12345678910&lt;!-- 简化路径 --&gt;resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &apos;styles&apos;: resolve(&apos;src/assets/styles&apos;), &apos;common&apos;: resolve(&apos;src/common&apos;) &#125;&#125;, config文件夹里面的index.js123456789101112131415&lt;!-- 修改api路径 模拟数据传入 --&gt;module.exports = &#123; dev: &#123; // Paths assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8080&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock/&apos; &#125; &#125; &#125;, src是主要操作及使用文件夹可添加common文件夹放置公用组件可添加assets文件夹放置公用的style字体css样式，styl样式可添加pages存放不同页面组件文件夹可添加store存放vuex所需的index.js文件static里创建mock文件夹存放json数据 gitignore存放上传时需要隐藏的文件1234567.DS_Storenode_modules//dist/npm-debug.log*yarn-debug.log*yarn-error.log*static/mock axios模块使用ajax123456789101112131415161718192021222324npm install axios --save&lt;!-- 在需要数据传输的主组件引用 --&gt;import axios from &apos;axios&apos;&lt;!-- get数据 --&gt;methods: &#123; getHomeInfo () &#123; axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc) &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data ) &#123; const data = res.data &lt;!-- 本组件中的data里面要已经创建好list数据 --&gt; this.list = data.swiperList &#125; &#125;&#125;mounted () &#123; this.getHomeInfo()&#125;&lt;!-- get到的数据传入到子组件中 --&gt;&lt;home-swiper :list=&quot;list&quot;&gt;&lt;/home-swiper&gt;子组件使用props接收使用 每次路由切换的时候都进入的页面初始位置x,y轴都为0123scrollBehavior (to, from, savedPosition) &#123; return &#123;x: 0, y: 0&#125; &#125; better-scroll移动端滚动的解决方案12345678910111213141516171819npm install better-scroll --save &lt;!-- 需要使用的组件中使用 保证该组件的html结构如下 --&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;content&quot;&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- you can put some other DOMs here, it won&apos;t affect the scrolling --&gt;&lt;/div&gt;&lt;!-- 引用 --&gt;import Bscroll from &apos;better-scroll&apos;&lt;!-- 创建mounted生命周期钩子 --&gt;mounted () &#123; this.scroll = new Bscroll(this.$refs.wrapper)&#125;&lt;!-- 需要设置的盒子设置 ref --&gt;&lt;div class=&quot;list&quot; ref=&quot;wrapper&quot;&gt; &lt;/div&gt; 设置数据接口先将json数据放在static文件夹的mock中在build文件夹的webpack.dev.config文件中作如下设置12345678910111213141516171819202122232425262728...........const portfinder = require(&apos;portfinder&apos;)const express = require(&apos;express&apos;)const app = express()var appData = require(&apos;../static/mock/data.json&apos;)var seller = appData.sellervar goods = appData.goodsvar ratings = appData.ratingsvar apiRoutes = express.Router()app.use(&apos;/api&apos;,apiRoutes)devServer:&#123; ............ before(app)&#123; app.get(&apos;/api/seller&apos;,function(req,res)&#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;), app.get(&apos;/api/goods&apos;,function(req,res)&#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;), &#125; 现在在浏览器输入http://localhost:8080/api/seller即可得到seller数据 点击路由高亮 &amp;.router-link-active1234567.tab-item flex: 1 text-align: center font-size: 14px color: rgb(77,85,93) &amp;.router-link-active color: rgb(240,240,20) 修改边框颜色123.border-bottom &amp;:before border-color: red 在vue中使用es6语法${}引用12345678910payDesc () &#123; if (this.totalPrice == 0 ) &#123; return `￥$&#123;this.seller.minPrice&#125;元起送` &#125;else if (this.totalPrice &lt; this.minPrice) &#123; let diff = this.minPrice - this.totalPrice return `还差￥$&#123;diff&#125;元起送` &#125;else &#123; return &apos;去结算&apos; &#125;&#125;, 使盒子水平排列的方法1 position (父)relative （子）absolute2 （子）float left right3 (父) display: flex 子flex: 1 或flex: 0 0 20px4 （子） display: inline-block 使用了better-scroll的区域点击失效使用click:true1234this.foodsscroll = new Bscroll(this.$refs.fwrapper,&#123; click: true, probeType: 3 &#125;) 外卖项目注：v-show能接收到food的count值1Vue.set(this.food,&apos;count&apos;,1)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试试题]]></title>
    <url>%2F2019%2F04%2F07%2Fexamination%2F</url>
    <content type="text"><![CDATA[第一章：全局作用域与私有作用域，变量提升 112345678console.log(a); //a 是全局变量 var a = 12; // 预解析变量提升 提升后不赋值，使a为undefinedfunction fn()&#123; // 私有作用域内声明了一个私有变量a 道理同上为undefined console.log(a); var a = 13; &#125;fn(); // (补充：fn执行形成一个私有作用域，1相残赋值,没有形参 2 变量a提升，所以fn内的所有a都是私有变量)console.log(a) // 此处的a为全局变量，12 答案： undefined undefined 12 212345678console.log(a);//此处同1号题var a = 12;function fn()&#123; console.log(a); a = 13; //此处和1号题区别，没有var声明，则此局部作用域内的a为全局变量，所以a被赋值了13&#125;fn();console.log(a); 答案： undefined 12 13 312345678console.log(a);// 全局作用下提升变量 报错 控制台只有报错信息a = 12; // 没有var 则不需要提升function fn()&#123; console.log(a); a = 13;&#125;fn(); console.log(a);// 补充：如果去掉第一行代码，以下正常执行输出12 13 答案： 有程序报错 412345678var foo = 1; //声明全局变量foo为10function bar()&#123; //形参赋值：无；变量提升：foo(不管下面的条件成立是否都要提升只是新浏览器中对于判断体的函数只是提前声明) if(!foo)&#123; //此时私有foo是undefined 取反为true 执行代码 var foo = 10; &#125; console.log(foo);&#125;bar(); 答案： 10 512345678910111213var n = 0 ;function a()&#123; var n = 10; function b()&#123; n++; console.log(n); &#125; b(); return b;&#125;var c = a();c();console.log(n); 答案：11 12 0 612345678910var a = 10,b = 11, c = 12;function test(a)&#123; a = 1; //a 是该函数的形参为私有变量，但是实参为10，此时a为10 var b = 2; //b被声明，所以为私有变量 赋值2 c = 3; // c在全局被声明，此处的c为全局变量，且重新赋值为3&#125;test(10);console.log(a);console.log(b);console.log(c); 答案：10 11 3 71234if(!(&quot;a&quot; in window))&#123;//注意：此大括号内为块级作用域，a为全局作用域的变量，即使条件不成立也会提前声明为undefined var a = 1;&#125;console.log(a); 答案：undefined(补充：相当于给window设置了一个对象的属性，而且两者间建立了映射的机制，所以此处&lt;=&gt;window.a = undefined; in:检测某个属性是否隶属于这个对象，不管是私有还是公有，有的话就是true。hasOwnProperty检测是否为某个对象的私有属性。) 812345678var a = 4;function b(x,y,a)&#123; console.log(a); // 与以上题目道理相同 arguments[2] = 10; // 第三个实参值修改为10 console.log(a);&#125;a = b(1,2,3);// b执行没有return,默认返回undefined，则a成为了undefinedconsole.log(a); 答案：3 10 undefined（补充：arguments[]—函数内置的实参集合，不管是否设置形参值，传递的实参值都会存在里面,JS非严格模式下,函数中的形参变量和arguments存在映射机制,形参变量的值会随着arguments []的值修改。严格模式：“use strict” 下的分析，如下：123456789function fn(x,y)&#123; var arg = arguments; arg[0] = 100; //arg内部只有一个映射 console.log(x); // 100 y = 200; consle.log(y);// y 赋值为200 console.log(arg[1]);//arg内部没有arg[1],所以为undefined&#125;fn(10);// 此时只为x赋值,y为undefined ） Tips: 严格模式与非严格模式下的区别1 严格模式下不支持使用arguments.callee和arguments.caller。2 严格模式下arguments和形参没有映射机制3 严格模式下，不允给一个对象的属性重复设置值，会出现两次值，而非严格模式是修改效果4 严格模式下，函数执行，如果没有明确指定主体（即函数前面没有点），就不再像非严格模式下一样把this指向window,而是指向undefined，代表没有执行主体。只有存在的情况下才指向执行主体 第二章：逻辑或||和逻辑与&amp;&amp;11234567var foo = &quot;hello&quot;;(function(foo)&#123; //形参赋值foo，变量提升省略，因为已经有foo这变量了，浏览器不会重新声明 console.log(foo); var foo = foo||&quot;world&quot;; // console.log(foo);&#125;)(foo);//将全局下的foo的值作为实参传递给自执行函数的形参console.log(foo); 答案：hello hello hello补充：使用到逻辑与和逻辑或的场合：(逻辑与的运算优先级高于逻辑或参照逻辑运算符)1 条件判断中使用到（两者都成立或有一个成立则判断条件才成立）2 赋值操作。var a = “1||2” ,验证1的真假：若1为真，赋值1；若为假，赋值2；var a=1&amp;&amp;2,验证1的真假：若为真，赋值2；若为假，赋值1。 第三章：堆栈内存释放112345678910111213！待定：var a = 9;function fn()&#123; a = 0;//私有变量a return function(b)&#123; return b+a++;//此处++不参与运算，但a也会加1加上括号（++）也一样 &#125;&#125;var f=fn();console.log(f(5)); //此处和下面同一个意思，都是5，但是其中的a未被销毁console.log(fn()(5));// a的值未被占用，被销毁console.log(f(5)); //f指针指向的第二次执行 a已经为1 console.log(a); 答案：5 5 6 2 21234567891011var i = 10;function fn()&#123; return function (n)&#123; console.log(n+(++i)); //此处i为全局变量，且++计算入总结果注意与上题区别 &#125; &#125;var f = fn();f(20);fn()(20)fn()(30)f(30) 答案: 31 32 43 44 312345678910var ary = [1,2,3,4];//开辟一个堆内存，让全局下的ary=bbbfff111function fn(ary)&#123; //把全局的ary的值传给了私有ary ary[0] = 0;//给里面的ary重新赋值[0,2,3,4] 因为两个ary指针指向同一个地方 ary = [0]; //开辟一个新的空间 ary=bbbfff222对应[0（0）] ary[0] = 100;// 现在改成[0（100）] return ary;// 相当于return bbbfff222&#125;var res = fn(ary);// res = fn(bbbfff111)=bbbfff222,这里有指针指向的改变console.log(ary);//[0,2,3,4]console.log(res); //[100] 答案： [0,2,3,4] [100]基本类型和引用类型]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建基本步骤]]></title>
    <url>%2F2019%2F04%2F07%2Fblog-construction%2F</url>
    <content type="text"><![CDATA[关于博客的基本概念来源：博客一词来源于weblog（网络日记），而喜欢新名词的人故意将该词变换称为“we blog”，就此诞生了“blog”极其音译“博客”，而编写该日志的人则被称为”blogger“，即博主。 作用：简单来说，blog就是以网络为载体的综合性平台，由简单易懂且经常更新的帖子构成，这些帖子按照更新时间倒序排列，其中可以记录你在生活，工作等任何领域的想法观点，上传自己想收藏起来的照片视频音频等文件，还可以与他人进行轻松有效的交流。 现在开始搭建博客：1 ：全局配置等准备工作1 安装Node.js和配置Node.js环境，官网直接下载即可。这是一个安装细节传送门检验是否安装成功：打开cmd命令行，由于是全局安装所以不需要修改文件夹。键入如下字符显示版本,则代表已经安装好，同时键入npm -v也会出现版本号，这是由于node.js附带安装了npm包管理工具1234C:\Users\Administrator&gt;node -vv10.15.3C:\Users\Administrator&gt;npm -v6.9.0 2 去github官网注册一个账号3 安装git工具：Git官网直接下载安装程序，安装完成后在cmd中输入git弹出命令行窗口，则表示安装成功，下面就要绑定自己的github账号12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 2 ： 开始安装HEXO1 创建blog文件夹，进入文件夹中右键git打开命令行输入命令1npm install -g hexo-cli 可以使用hexo -v查看版本，安装完成2 初始化hexo 为自己的blog取名。cd到文件夹中安装依赖123hexo init myblogcd myblognpm install 3 命令行中输入hexo g 生成静态页面，hexo s开启服务，根据提示端口号进入页面123hexo ghexo sINFO Hexo is running at http://localhost:4000/ 到目前为止，HEXO在本地的配置已经结束，我们下面要将本地的代码上传到github上 3 ： github配置1 前面我们已经注册好了一个github账号，点击NEW repository新建代码仓库创建页面在在Repository name 下面填写yourname.github.ioyourname就是你想要使用的名字，下面的描述可以不写，点击创建即可2 现在让本地的git项目与远程的github建立联系，使用SSH keys3 生成SSH Keys : 在命令行中使用如下命令，输入你自己的邮箱地址1ssh-keygen -t rsa -C &quot;xxxx@qq.com&quot; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码4 添加 SSH Key 到 GitHub: 打开 C:\Users\lijun.ssh\id_rsa.pub，此文件里面内容为刚生成的密钥，准确的复制这个文件里的内容，粘贴到 https://github.com/settings/ssh 的new SSH key中5 测试是否添加成功 :可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：1ssh -T git@github.com 出现如下反馈123The authenticity of host ‘github.com (207.97.227.239)’ can’t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 下面键入yes出现成功提示1Hi AnkZhang! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 6 配置 Deployment在_config.yml文件中(此文件在你创建好的Hexo站点目录中)，找到Deployment，然后按照如下修改，用户名改成你自己的GitHub信息：(冒号后一定要空一格)123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/AnkZhang/AnkZhang.github.io.git branch: master 7 本地文件提交到github123456// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate// 开始部署hexo deploye 出现以下提示说明部署成功：1[info] Deploy done: git 注意1：若上面操作失败，则需要提前安装一个扩展：1npm install hexo-deployer-git --save 注意2：如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。1234Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 4： HEXO常用命令1234567891011121314hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 就此HEXO博客搭建完成]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客文章]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一章这是我的第一篇文章，哎呀好耶！这是一个三级标题 列表1 列表2 a 字列表哦 b 字列表哦 列表3 这是我的github链接 评论系统的第三方邮件提醒无法布置怎么完善评论系统 我怎么斜了 我怎么粗了 &lt;html&gt;我是一个单行的代码块&lt;/html&gt; 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;我是一个标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是一个div盒子&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我这里引用了别人的段落注意，我的字体也不一样哦]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
</search>
